Техническая спецификация: Telegram-бот (aiogram) для тестирования с хранением вопросов в Google Sheets

⸻

Краткое описание

Бот на aiogram проводит тест: выбирает N вопросов (N — параметр из админ-листа Google Sheets), спрашивает пользователя последовательно, отсчитывает время на каждый вопрос, ведёт счётчик допустимых ошибок (баллов) и завершает тест при достижении 0 баллов (не пройден) или после корректного ответа на все вопросы (пройден). Вопросы хранятся в Google Sheets (один документ, несколько листов). Состояние активных сессий хранится в Redis (FSM). База данных не используется. Логи проходят через стандартный логгер (logger.info).

⸻

Документы Google Sheets — структура и формат

Документ: один Google Sheets (один файл). Листы (вкладки):

1) Вкладка Questions

Колонки (заголовки в первой строке):
	•	Категория — строка (например: “Математика”, “Безопасность”).
	•	Вопрос — текст вопроса.
	•	Ответ 1 — текст варианта 1.
	•	Ответ 2 — текст варианта 2.
	•	Ответ 3 — текст варианта 3.
	•	Ответ 4 — текст варианта 4.
	•	Правильный ответ — целое число 1..4 (индекс правильного варианта).
	•	(опционально) ID — уникальный идентификатор вопроса (если отсутствует, используем строковый индекс/позицию).

Примечания:
	•	Категорий может быть любое количество и оно может меняться.
	•	Допускаются одинаковые тексты в разных строках — считаются разными вопросами (по строке/ID).

2) Вкладка Admin

Одна строка (или набор ключ-значение) с параметрами конфигурации теста:
	•	Количество вопросов — целое N (например 20).
	•	Количество допустимых ошибок — целое M (например 3). Это начальный «балл» (количество допустимых ошибок), т.е. при каждом неверном ответе балл уменьшается на 1; при достижении 0 тест прерывается и считается непройденным.
	•	Как часто можно проходить тест (часов) — целое H (например 24). Пользователь может сдавать повторно только если с последней записи в Results прошло >= H часов.
	•	Количество секунд на одно задание — целое S (таймаут в секундах на каждый вопрос).
	•	(опционально) Дата/версия вопросов — для администраторов (версионирование).

Примечание: админские настройки редактируются вручную в Google Sheets администратором.

3) Вкладка Results

При каждом завершении теста новая строка добавляется в конец:
Колонки:
	•	telegram_id — целое.
	•	username — строка (если есть).
	•	first_name — строка (если есть).
	•	last_name — строка (если есть).
	•	Дата прохождения теста — ISO-формат даты/времени (в часовом поясе сервера; в ТЗ — America/New_York).
	•	ФИО — строка (введённое и подтверждённое пользователем).
	•	результат — строка: Пройден / Не пройден.
	•	количество верных ответов — целое.
	•	(опционально) примечания — текст (например: “таймаут на вопрос #5”).

Примечание: Admin лист содержит начальные значения, но в Results также фиксируется фактическое количество вопросов (при желании можно дублировать).

⸻

Архитектура системы и компоненты
	1.	Telegram-бот (aiogram) — основной сервис. Исполняется как контейнер (Docker). Отвечает на сообщения, управляет FSM, общается с Google Sheets и Redis.
	2.	Redis — хранение сессий/состояний FSM и временных данных в памяти. Используется только для активных сессий (не как БД).
	3.	Google Sheets API (Google Service Account) — чтение листов Questions, Admin, запись в Results.
	4.	Логирование — стандартный Python logger (stdout). logger.info для бизнес-логов (вопрос, ответ, correct/incorrect).
	5.	Docker-compose — опционально для локальной/production среды: сервисы bot и redis.

Развёртывание: контейнер с ботом + контейнер redis. Настройка env vars и секретов (токен Telegram, credentials JSON для Google) через механизмы хостинга/CI.

⸻

Переменные окружения (минимум)
	•	TELEGRAM_TOKEN — токен бота.
	•	GOOGLE_CREDENTIALS_JSON — содержимое JSON сервисного аккаунта (или путь к файлу).
	•	SHEET_ID — ID Google Sheets документа.
	•	REDIS_URL — адрес Redis (например redis://redis:6379/0).
	•	TIMEZONE — “America/New_York”.
	•	LOG_LEVEL — INFO/DEBUG.
	•	SESSION_TTL_PADDING — опционально: padding для TTL сессии.

Секреты должны храниться в безопасном месте (Vault, k8s secrets, Docker secret) — не в репозитории.

⸻

Общая логика взаимодействия с пользователем (UX flow)
	1.	Пользователь отправляет команду /start или /test.
	2.	Бот приветствует, кратко объясняет правила (N вопросов, таймаут S сек/вопрос, допустимых ошибок M).
	3.	Бот просит ввести ФИО (имя фамилия отчество) как одну строку.
	4.	Пользователь вводит ФИО.
	5.	Бот просит подтвердить (кнопки: “Подтвердить” / “Ввести снова”).
	•	Если “Ввести снова” — вернуться к шагу ввода ФИО.
	•	Если “Подтвердить” — продолжить.
	6.	Перед началом теста бот:
	•	Считывает Admin лист (параметры N, M, H, S).
	•	Проверяет Results на время последнего прохождения для этого telegram_id. Если последнее прохождение было меньше чем H часов назад — отвечает, что пересдать пока нельзя, указывает оставшееся время до разрешённого повторного прохождения — и прекращает.
	•	Загружает все вопросы из Questions листа.
	•	Формирует выборку из N вопросов по алгоритму распределения по категориям (см. ниже).
	•	Создаёт сессию в Redis с начальным состоянием FSM и устанавливает TTL.
	7.	Бот задаёт вопросы по очереди:
	•	Для каждого вопроса бот отправляет текст и 4 кнопки варинтов (Ответ 1..4).
	•	Устанавливается таймер на S секунд: если пользователь не ответил в S секунд — считается, что он не прошёл тест (балл становится 0); бот завершает тест и записывает результат в Results.
	•	При ответе бот проверяет индекс (1..4) с полем Правильный ответ. Если корректно — увеличивает correct_count и идёт к следующему вопросу. Если некорректно — уменьшает remaining_score на 1; если remaining_score==0 => тест завершается как Не пройден.
	8.	По завершении (прошёл/не прошёл) бот:
	•	Сообщает пользователю “Вы прошли тест” или “Вы не прошли тест” (другую подробную статистику не показывает).
	•	Сохраняет запись в Results (telegram_id, username, first_name, last_name, дата, ФИО, результат, количество верных ответов).
	•	Логирует всю сессию через logger.info (включая последовательность вопросов и ответы — для отладки).
	9.	Сессия удаляется из Redis (или истекает по TTL).

⸻

FSM (состояния) — названия и поля

Предлагаемые состояния:
	•	START — приветствие; можно реагировать на /start.
	•	COLLECT_FIO — ожидается ввод ФИО.
	•	CONFIRM_FIO — ожидается подтверждение ФИО.
	•	PREPARE_TEST — бот готовит выборку вопросов; считывает конфиги.
	•	ASKING — активный тест; под-состояние содержит: current_index (0..N-1), question_ids (список), remaining_score, correct_count, start_timestamp, expires_at (опционально), per_question_deadline (timestamp).
	•	WAIT_ANSWER — ожидается ответ на текущий вопрос (таймаут S).
	•	FINISHED — тест завершён, отправлен результат.

Данные сессии в Redis (ключи/структура):
Для каждого пользователя (по telegram_id) создаётся ключ session:{telegram_id} (value — сериализованный JSON) с полями:
	•	fio : string
	•	question_ids : list[int] (или list[str])
	•	current_index : int
	•	remaining_score : int
	•	correct_count : int
	•	started_at : timestamp
	•	last_action_at : timestamp
	•	per_question_deadline : timestamp (deadline для текущего вопроса)
	•	ttl : время жизни сессии (устанавливается как Redis TTL)
	•	admin_config_snapshot : {N, M, S, H} — сохранённая копия конфигурации теста на момент старта

Redis TTL:
	•	TTL >= Количество вопросов * S + padding (например +60 сек) — гарантирует очистку брошенных сессий.

⸻

Алгоритм выбора N вопросов (пропорциональное распределение по категориям)

Цель: выбрать N вопросов случайно, равномерно распределённых по категориям по пропорции наличия вопросов, при этом без повторения в одной сессии.

Шаги:
	1.	Из Questions формируем карту категорий → список вопросов в категории.
	2.	Считаем общее количество вопросов в таблице total_questions_in_sheet.
	3.	Для каждой категории c вычисляем взвешенное количество вопросов:
	•	raw = N * (count_c / total_questions_in_sheet).
	•	quota_c = floor(raw) — начальное целое.
	4.	Распределяем оставшиеся (из-за округления) однообразно: пока сумма quota_c < N, добавляем +1 категориям с наибольшими дробными частями raw - floor(raw) (стандартный метод распределения округлений).
	5.	Если для какой-то категории quota_c > count_c (т.е. в категории меньше вопросов, чем назначено), тогда:
	•	Устанавливаем quota_c = count_c.
	•	Оставшийся недостающий квотный объём перераспределяем среди остальных категорий по тому же методу (повторить шаги распределения).
	6.	После получения финальной таблицы quota_c по категориям, из каждой категории случайно (без повторений) выбираются quota_c вопросов.
	7.	Если после всех попыток суммарное количество < N (например, всего вопросов в таблице < N) — это проверка: сообщить администратору или на момент старта уменьшить фактическое N до доступного количества и продолжить. В спецификации — предусмотреть поведение:
	•	prefered behavior: если total_questions_in_sheet < N => бот уменьшает N до total_questions_in_sheet и уведомляет (в сообщении) администратора или в логах.

Примечание:
	•	Категории могут повторяться в итоговой выборке — это допустимо, потому что распределение по категориям пропорционально.
	•	Внутри сессии вопросы не повторяются.

⸻

Логика оценки (баллы/ошибки)
	1.	При старте теста remaining_score устанавливается равной Количество допустимых ошибок (Admin M).
	2.	При каждом ответе:
	•	Если ответ индекс совпадает с Правильный ответ — correct_count += 1.
	•	Иначе — remaining_score -= 1.
	3.	Если после уменьшения remaining_score == 0 — тест завершается немедленно как Не пройден (баллы исчерпаны).
	4.	Если пользователь отвечает на все N вопросов и remaining_score > 0 — тест считается Пройден.
	5.	При таймауте на вопрос (пользователь не ответил за S секунд) — тест автоматически считается Не пройден, remaining_score := 0, записывается соответствующий итог и фиксируется в Results как не пройденный (в поле примечания указать “таймаут на вопрос #k”).

⸻

Таймауты и механизм отсчёта времени
	•	S = Количество секунд на одно задание (Admin).
	•	При отправке вопроса бот устанавливает deadline = now + S.
	•	Реализация таймаута:
	•	Для надёжности: записать per_question_deadline в Redis и установить Redis TTL для сессии; одновременно запустить асинхронный таймер/задачу в боте, которая ждёт S секунд и проверяет, не пришёл ли ответ (если всё ещё ожидается — завершает сессию).
	•	Альтернативно: использовать фоновые планировщики (aiogram built-in job queue или asyncio tasks). В любом случае, логика: когда приходит ответ, проверять текущее время <= per_question_deadline. Если позднее — считать таймаутом.
	•	Если пользователь присылает ответ после таймаута — бот сообщает, что тест уже завершён или тайм-аут сработал.

⸻

Политика повторных прохождений
	•	Параметр Как часто можно проходить тест (часов) = H берётся из админ-листа.
	•	Проверка:
	•	До старта теста проверяем вкладку Results по telegram_id — ищем последнюю запись.
	•	Если последняя запись находится менее чем H часов назад — бот отклоняет попытку, сообщает сколько часов/минут осталось до разрешённой даты (вычисление: last_time + H часов − now).
	•	При отсутствии предыдущих записей — разрешаем начать.

⸻

Работа с Google Sheets API (операции и ограничения)

Операции:
	•	Чтение Admin листа — при каждом старте теста.
	•	Чтение всего Questions листа — при старте теста (или кэшировать на короткое время; но всегда читать при старте — проще).
	•	Запись новой строки в Results — в конце теста.

Практические рекомендации и замечания:
	•	Использовать Service Account с правом доступа только к конкретному Google Sheet (share с email сервисного аккаунта).
	•	Минимизировать число запросов: считывать Questions и Admin один раз в начале теста.
	•	Обработать ошибки сети и квоты API:
	•	При ошибках чтения/записи — логировать и сообщать пользователю дружелюбное сообщение об ошибке (“Временно недоступно — повторите позже”).
	•	Повторная попытка записи в Results при временных ошибках — несколько попыток с экспоненциальной задержкой.
	•	Если частые чтения вопросов создают узкое место — учитывать кэширование (in-memory) в контейнере, но обновление параметров в Admin при изменениях не будет мгновенным.

⸻

Логирование и мониторинг

Логирование:
	•	Использовать logger.info для бизнес-событий:
	•	старт/конец сессии (telegram_id, FIO, результат, correct_count),
	•	каждый заданный вопрос: id, текст (или id), пользователю отправлено,
	•	ответ пользователя: выбранный индекс, корректность, timestamp,
	•	таймауты, ошибки Google API, Redis ошибки.
	•	Уровень DEBUG для разработки: подробные трассировки.

Мониторинг:
	•	Метрики:
	•	активные сессии (число ключей session:* в Redis),
	•	количество успешно завершённых/неуспешных тестов в день,
	•	ошибки Google Sheets API (rate-limit),
	•	средняя длительность сессии.
	•	Экспорт логов в stdout (для Docker) — далее в лог-агрегатор (опционально).

⸻

Ошибки и граничные случаи
	1.	Мало вопросов в таблице (< N):
	•	поведение: уменьшить N до доступного количества и логировать; сообщить админу в логах; или отказать в старте (настраиваемо). Рекомендуем: автоматически уменьшать N и продолжать.
	2.	Нет вопросов в таблице — отказ с дружелюбным сообщением.
	3.	Ошибка записи в Results — повторять запись; если не удалось, сообщить пользователю, что результат сохранён локально и будет отправлен позже (но так как нет безопасного хранилища, логгировать событие и уведомить админа).
	4.	Проблемы с таймаутом (падение бота) — Redis хранит сессию и deadline; при рестарте бот должен при старте восстанавливать/обрабатывать сессии, у которых deadline уже прошёл (пометить как таймаут и завершить).
	5.	Нарушение формата в Questions (например, Правильный ответ не 1..4) — при загрузке вопросов такие строки пометить и пропустить; логировать.

⸻

Безопасность и приватность
	•	Telegram ID и ФИО хранятся в Results. Адрес хранения — Google Sheets; доступ имеет только администратор и сервисный аккаунт.
	•	Не хранить в логе чувствительные данные (например, полностью текст вопросов, если это конфиденциально) — логировать id вопросов и метаданные.
	•	Токен Telegram и Google credentials — хранить как секреты, не в коде.
	•	Ограничивать доступ к Google Sheets: делиться только с сервисным аккаунтом.
	•	Обработка персональных данных — согласие администратора и соблюдение юридических требований (если применимо).

⸻

Хранение состояния и Redis — шаблон ключей и TTL

Ключи:
	•	session:{telegram_id} — JSON с полями сессии (см. FSM).
	•	(опционально) lock:questions_reload — для синхронизации при параллельном доступе.

TTL:
	•	Установить TTL = Количество вопросов * S + 300 секунд (padding) при создании сессии.
	•	При каждом активном действии обновлять last_action_at (не обязательно TTL; но можно refresh TTL при каждом ответе).

Преимущества Redis:
	•	Надёжное хранение состояния между перезапусками бота.
	•	Удобные операции atomic (INCR, GETSET) при многопоточности.

⸻

Интеграция и тестирование

Unit & Integration tests:
	•	Тест алгоритма распределения по категориям (входные размеры, округления).
	•	Тест обработки таймаута (галочка, что по истечении S сессия завершается).
	•	Тесты на читаемость/запись Google Sheets: мокировать API (не использовать реальные креды в CI).
	•	Тесты на обработку ошибок API (симулировать rate-limit, ошибки сети).
	•	Тесты для повторных прохождений (проверка H часов).

Инструменты:
	•	CI запускает unit-тесты; интеграционные тесты с локальным Redis и моками Google Sheets.

⸻

Развёртывание (Docker / Docker-compose)

Рекомендуемая конфигурация docker-compose:
	•	Сервис bot — контейнер с приложением (aiogram).
	•	Сервис redis — контейнер redis:7 (или совместимая версия).
	•	Секреты и env vars задаются через .env и Docker secrets (производство).

Ресурсы контейнера:
	•	Для ~100 одновременных пользователей: 0.5–1 vCPU, 512–1024 MB RAM обычно достаточно (зависит от частоты запросов к Google Sheets). Если ожидание больше — масштабировать.

⸻

Логика безопасности при параллельных сессиях и конкуренции
	•	Каждому telegram_id соответствует только одна активная сессия — при попытке запустить новую тест с тем же telegram_id, если сессия активна, бот сообщит, что тест уже идёт.
	•	При записи в Results использовать атомарность (append row API у Google Sheets) — гарантировать, что не перезаписываются данные.

⸻

Рекомендации по развитию и дополнительные фичи (опционально)
	•	UI: добавить краткую статистику в админский лист (сколько попыток в день, процент прохождений).
	•	Отправка уведомлений админу при падении Google API или при ошибках записи.
	•	Возможность в Admin листе переключать режимы формирования вопросов (например, минимум 1 вопрос в каждой категории).
	•	Экспорт результатов в CSV / бэкапы Google Sheet.
	•	Вариант «квалификационный порог» — требуемое min correct_count для прохождения (вместо или в дополнение к M).

⸻

Контроль качества и приемка

Критерии приёмки:
	1.	Бот корректно читает Admin и Questions и формирует выборку N вопросов.
	2.	Вопросы распределены пропорционально по категориям, без повторов в одной сессии.
	3.	При каждом неверном ответе remaining_score уменьшается; при достижении 0 тест завершается как “Не пройден”.
	4.	По таймауту S сек тест прерывается и считается “Не пройден”.
	5.	Результат записывается в лист Results с требуемыми полями.
	6.	Ограничение повторного прохождения по H часам соблюдается.
	7.	Активные сессии устойчиво хранятся в Redis и восстанавливаются корректно после рестарта (timeout handling).
	8.	Логи пишутся через logger.info с необходимыми полями.

⸻

Итоги (чеклист для реализации)
	1.	Настроить доступ Google Service Account к Google Sheets.
	2.	Настроить Docker + Redis окружение.
	3.	Реализовать FSM согласно описанию.
	4.	Реализовать алгоритм распределения вопросов по категориям (quota).
	5.	Реализовать таймауты на вопрос, логику завершения при 0 баллов и таймауте.
	6.	Реализовать чтение/запись в Google Sheets (Admin/Questions/Results).
	7.	Реализовать проверку ограничений повторных попыток H часов.
	8.	Ведение логов: logger.info (все вопросы/ответы/результат).
	9.	Настроить мониторинг и обработку ошибок API.

