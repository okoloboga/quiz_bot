# Детальный план реализации расширенного функционала

Этот документ описывает подробную логику и шаги для реализации нового функционала.

## 1. Изменения в конфигурации

В файл `.env` будут добавлены следующие переменные (и загружаться в `config.py`):
- `OWNER_TELEGRAM_ID`: Telegram ID владельца бота для пересылки ему обращений от пользователей.
- `ADMIN_TELEGRAM_ID`: Telegram ID администратора для отправки ему отчётов и служебных уведомлений.

## 2. Модификация структуры Google Sheets

Структура листов Google Sheets будет расширена для поддержки нового функционала, как описано в предыдущей версии плана. Ниже представлены обновленные названия листов и колонок:

### Лист "Пользователи"
Колонки:
- `telegram_id`
- `телефон`
- `фио`
- `автоколонна`
- `статус`

### Лист "Кампании"
Колонки:
- `название_кампании`
- `дедлайн`
- `тип` (`Обучение`/`Тестирование`)
- `тип_назначения` (`Пользователь`/`Автоколонна`)
- `значение_назначения`

### Лист "Вопросы" (обновленные колонки)
- `критический_вопрос` (Boolean)
- `пояснение` (Text)

### Лист "Результаты" (обновленные колонки)
- `итоговый_статус` (Text)
- `название_кампании` (Text)

## 3. Детальное описание архитектуры и логики

### 3.1. Middleware для проверки статуса пользователя

- **Назначение**: Перехватывать все входящие сообщения и команды от пользователя.
- **Логика**:
    1.  Для каждого сообщения извлекается `telegram_id` пользователя.
    2.  Выполняется запрос к листу `Пользователи` для получения статуса этого пользователя.
    3.  **Если статус не "подтверждён"**:
        - Проверяется, не находится ли пользователь в процессе регистрации (в состояниях FSM, связанных с регистрацией). Если да, обработка продолжается.
        - В противном случае, обработка сообщения прерывается, и пользователю отправляется уведомление: "Ваша учётная запись ожидает подтверждения администратором. Доступ к функционалу ограничен."
    4.  **Если пользователь не найден** в листе `Пользователи`, запускается флоу регистрации.
    5.  **Если статус "подтверждён"**, обработка сообщения передаётся дальше соответствующим хендлерам.

### 3.2. Флоу регистрации (FSM)

- **Состояния FSM**:
    - `Registration:waiting_for_phone`
    - `Registration:waiting_for_fio`
    - `Registration:waiting_for_motorcade`
- **Логика**:
    1.  **Запуск**: Хендлер команды `/start`, если пользователя нет в базе, переводит его в состояние `Registration:waiting_for_phone` и запрашивает номер телефона.
    2.  **Получение телефона**: Хендлер, срабатывающий на получение контакта или текста в этом состоянии, сохраняет телефон в FSM storage, переводит в состояние `Registration:waiting_for_fio` и запрашивает ФИО.
    3.  **Получение ФИО**: Хендлер сохраняет ФИО, переводит в состояние `Registration:waiting_for_motorcade` и запрашивает название автоколонны.
    4.  **Получение автоколонны**: Хендлер сохраняет название. Теперь все данные собраны.
    5.  **Запись в Google Sheets**: Вызывается функция сервисного слоя, которая добавляет новую строку со всеми собранными данными и статусом "ожидает" в лист `Пользователи`.
    6.  **Завершение**: Пользователю отправляется сообщение об успешной регистрации и необходимости ожидать подтверждения. Состояние FSM сбрасывается.

### 3.3. Логика определения и запуска кампаний

- **Функция `get_active_campaign_for_user(user_id)`**:
    - **Назначение**: Найти одну активную, не пройденную кампанию для конкретного пользователя.
    - **Логика**:
        1.  Получить данные пользователя (`фио`, `автоколонна`) из листа `Пользователи`.
        2.  Получить список всех кампаний из листа `Кампании`.
        3.  Отфильтровать кампании, у которых `дедлайн` уже прошел.
        4.  Пройтись по оставшимся кампаниям и определить, является ли пользователь участником, сверяя `тип_назначения` и `значение_назначения` с данными пользователя.
        5.  Для каждой подходящей кампании проверить лист `Результаты`: если для пары `user_id` и `название_кампании` есть запись со статусом "пройдено", эта кампания игнорируется.
        6.  Вернуть первую найденную кампанию, которая удовлетворяет всем условиям.
- **Хендлер команды `/start` (для подтверждённых пользователей)**:
    1.  Вызывает `get_active_campaign_for_user`.
    2.  Если кампания найдена, показывает пользователю Inline-кнопку "Начать" с `callback_data`, содержащим `название_кампании`.
    3.  Если нет, сообщает, что доступных кампаний нет, и предлагает пройти общий тест (старая логика).
- **Хендлер `callback_query` (нажатие кнопки "Начать")**:
    1.  Извлекает `название_кампании`.
    2.  Проверяет в `Результаты` статус последней попытки для этой кампании. Если статус "не пройдено", то проверяет, есть ли отметка "разрешена пересдача".
    3.  Если доступ разрешен, запускает процесс подготовки к тесту: загружает вопросы, формирует сессию в Redis, сохраняя в ней `название_кампании` и `тип` (`Обучение`/`Тестирование`).

### 3.4. Модификация логики проведения теста

- **Хендлер ответа на вопрос**:
    - **Назначение**: Обработать ответ пользователя, обновить счёт и решить, что делать дальше.
    - **Логика**:
        1.  Проверяет правильность ответа.
        2.  **Если ответ НЕПРАВИЛЬНЫЙ**:
            - Загружает данные текущего вопроса, включая `критический_вопрос` и `пояснение`.
            - Проверяет, является ли вопрос критическим (`критический_вопрос == TRUE`). Если да, немедленно вызывает функцию `finish_test` с результатом "Не пройден".
            - Если вопрос не критический, уменьшает счётчик оставшихся ошибок.
            - Проверяет контекст теста в сессии Redis. Если режим `Обучение`, отправляет пользователю сообщение с текстом из колонки `пояснение`.
            - Если счётчик ошибок достиг нуля, вызывает `finish_test`.
            - В противном случае, отправляет следующий вопрос.
        3.  **Если ответ ПРАВИЛЬНЫЙ**:
            - Увеличивает счётчик правильных ответов и отправляет следующий вопрос.
- **Функция `finish_test(session_data, result)`**:
    - **Назначение**: Корректно завершить тест.
    - **Логика**:
        1.  Формирует запись для `Результаты` на основе данных из сессии (включая `название_кампании`).
        2.  Записывает эту строку в Google Sheets.
        3.  Отправляет пользователю итоговое сообщение ("Тест пройден" / "Тест не пройден").
        4.  Полностью очищает сессию пользователя из Redis.

### 3.5. Система уведомлений (Scheduler)

- **Инициализация**: При старте бота запускается `AsyncIOScheduler`.
- **Фоновая задача `check_deadlines_job()` (запускается раз в сутки)**:
    1.  Получает текущую дату.
    2.  Загружает полный список кампаний, пользователей и результатов. Это делается один раз для оптимизации.
    3.  Итерируется по кампаниям. Если до дедлайна 3 дня или 1 день:
        - Определяет список участников этой кампании.
        - Для каждого участника проверяет, есть ли у него в `Результаты` статус "пройдено" по этой кампании.
        - Если нет, отправляет ему персональное уведомление-напоминание. Все отправки оборачиваются в `try-except` для обработки случаев, когда бот заблокирован.

### 3.6. Флоу обращений к владельцу (FSM)

- **Состояние FSM**: `Appeal:writing_message`.
- **Логика**:
    1.  В главном меню есть кнопка "Написать обращение". При её нажатии пользователь переводится в состояние `Appeal:writing_message`, и бот просит ввести текст.
    2.  Хендлер, отлавливающий сообщения в этом состоянии, принимает текст.
    3.  Формирует сообщение вида: `Обращение от [ФИО] (ID: [telegram_id]):\n\n[текст сообщения]`.
    4.  Отправляет это сообщение на `OWNER_TELEGRAM_ID`.
    5.  Сообщает пользователю "Ваше обращение отправлено" и сбрасывает состояние.

### 3.7. Логика команд аналитики

- **Хендлер команд (e.g., `/stats_campaign <name>`)**:
    - **Назначение**: Предоставить администратору статистику.
    - **Логика**:
        1.  Проверяет, совпадает ли `telegram_id` пользователя с `ADMIN_TELEGRAM_ID`.
        2.  Если да, вызывает соответствующую функцию для генерации отчёта (например, `get_stats_for_campaign(name)`).
        3.  **Функция `get_stats_*`**:
            - Читает лист `Результаты`.
            - Фильтрует строки по заданным параметрам (название кампании, автоколонна и т.д.).
            - Агрегирует данные: считает % прохождения, средний балл, выявляет самые частые ошибки.
            - Форматирует результат в виде читаемого текстового сообщения.
        4.  Отправляет сгенерированный отчёт администратору.